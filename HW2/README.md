# HW2.[Meta-heuristic Algorithm]

##作業更正事項:調整程式碼使閱讀與使用上更加簡單，將各參數集中於開頭更方便做調整

## HW2.(1)[Hill Climbing]

### 此題所學
得知hill climbing algo主要結構為1.初始解 2.評估函數 3.鄰近解生成 4.選擇最優解 5.終止條件

### 各結構方法
###### 1.初始解部分採取完全隨機選取,若取超過capacity則由評估函數處理
###### 2.評估函數以超過capacity時profit為0來算出總profit即可 
###### 3.hill_climbing鄰近解生成在網路上查到有翻轉物品狀態的方式,判斷很適合用來解knapsack問題
###### 4.鄰近解與初始解相比取profit較大者
###### 5.迭代100次

### 簡短心路歷程
在經過多次嘗試後發現在此題中初始解的選取是最影響迭代次數的關鍵,但為了避免因各種問題的最佳解不同(eq.最佳解為全取或只取其中一件物品)而導致我的hill_climbing可能有特別的取物傾向,故仍維持以全隨機方式選擇初始解,而我選擇以"翻轉物品選取狀態"可以保證在無限次的迭代中一定可以找到最佳解,然而在無特別取物傾向的情況下,我認為此類型題目在相同問題規模下以hill_climbing似乎無法穩定在100次內迭代至最佳解

## HW2.(2)[Genetic Algo]

### 此題所學
得知genetic algo主要結構為1.初始化群體 2.適應度函數 3.選擇最優解 4.交叉與突變

### 各結構方法
###### 1.初始解群體部分採取完全隨機選取,若超過capacity則由適應度函數處理,發現若population_size取太大會一下子就找到最佳解而失去此演算法意義 
###### 2.適應度函數以超過capacity時profit為0來算出總profit即可 
###### 3.選profit最大的 
###### 4.交叉方式為隨機取兩父帶中的同一點做截斷後交叉接合,突變方式同hill_climbing的翻轉方式

### 簡短心路歷程
大致了解這個演算法後,覺得很像小時候常玩的猜幾A幾B的遊戲,優先以猜得最準的幾次去做交叉並適當的突變能更好得猜出答案,經過調整population_size後能穩定的以不快也不慢的速度收斂至最佳解,覺得在knapsack problem中以genetic algo來解是非常合適的,可以有效的過濾許多不良的猜測,也因為起始點多而大大的降低只找到區域最佳解的機率



### 在colab執行的前置作業
###### 1.將作業二的四個txt檔p06_c、p06_p、p06_s、p06_w放入新的資料夾命名為"Meta-heuristic Algorithm"
###### 2.將"Meta-heuristic Algorithm"與"作業二_Meta_heuristic_Algorithm.ipynb"上傳至google雲端硬碟中的"我的雲端硬碟"

### 若不在colab上執行,則須更改程式內以下路徑
###### (程式區塊二)"# 讀取資料"內的folder_path至四個資料所存放之資料夾路徑

### 程式流程

#### (程式區塊一)
###### 1.授權colab對雲端硬碟進行存取

#### (程式區塊二)
###### 2.讀取資料,考慮讓程式更方便理解並減少未來數據誤植發生可能,故選擇以item矩陣合併存取weight與profit 

#### (程式區塊三,此區塊實作Hill_Climbing)
###### 3.設定評估函數,目的為取得不超過capacity的最大profit
###### 4.設定hill_climbing函數,生成初始解與鄰近解,鄰近解採隨機翻轉一個物品選取狀態並與最佳解做比較
###### 5.執行hill_climbing並繪出圖片 

#### (程式區塊四,此區塊實作Genetic_Algo)
###### 6.設定基因演算法參數,定義適應度函數、初始化群體、交叉操作與突變操作
###### 7.設定genetic_algo函數,不斷讓profit較大的父代做交叉並讓子代有10%機率突變
###### 8.執行genetic_algo並繪出圖片
